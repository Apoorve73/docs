---
title: 'Nested queries'
metaTitle: 'Nested queries'
toc: true
tocDepth: 5
---

## <inlinecode>create</inlinecode>

A nested `create` query adds a new related record or set of records to a parent record. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>.

### Remarks

- `create` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.

> You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [each technique pros and cons](/concepts/components/prisma-client/relation-queries#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

### Examples

#### Create a new `User` record with a new `Profile` record

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

#### Create a new `Profile` record with a new `User` record

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
|     create: { email: 'alice@prisma.io' },
    },
  },
})
```

#### Create a new `User` record with a new `Post` record

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
  },
})
```

#### Create a new `User` record with two new `Post` records

Because it's a one-to-many relation, you can also create several `Post` records at once by passing an array to `create`:

```ts highlight=5;normal
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        {
          title: 'This is my first post',
        },
        {
          title: 'Here comes a second post',
        },
      ],
    },
  },
})
```

You can also use a nested [`createMany`](#createmany-1) to achieve the same result.

#### Update an existing `User` record by creating a new `Profile` record

```ts highlight=5;normal;
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      create: { bio: 'Hello World' },
    },
  },
})
```

#### Update an existing `User` record by creating a new `Post` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
|      create: { title: 'Hello World' },
    },
  },
})
```

## <inlinecode>createMany</inlinecode>

A nested `createMany` query adds a new set of records to a parent record. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>.

### Remarks

- `createMany` is available as a nested query when you `create` (`prisma.user.create(...)`) a new parent record or `update` (`prisma.user.update(...)`) an existing parent record.
- Available in the context of a has-many relation - for example, you can `prisma.user.create(...)` a user and use a nested `createMany` to create multiple posts (posts have one user).
- **Not** available in the context of a many-to-many relation - for example, you **cannot** `prisma.post.create(...)` a post and use a nested `createMany` to create categories (many posts have many categories).
- Does not support nesting additional relations - you cannot nest an additional `create` or `createMany`.
- Allows setting foreign keys directly - for example, setting the `categoryId` on a post.

> You can use a nested `create` _or_ a nested `createMany` to create multiple related records - [each technique pros and cons](/concepts/components/prisma-client/relation-queries#create-a-single-record-and-multiple-related-records) <span class="concept"></span>.

### Examples

#### Update a `User` and multiple new related `Post` records

```ts
const user = await prisma.user.update({
  where: {
    id: 9,
  },
  data: {
    name: 'Elliott',
    posts: {
      createMany: {
        data: [{ title: 'My first post' }, { title: 'My second post' }],
      },
    },
  },
})
```

## <inlinecode>set</inlinecode>

`set` overwrites the value of a relation - for example, replacing a list of `Post` records with a different list. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

### Examples

#### Update an existing `User` record by disconnecting any previous `Post` records and connecting two other existing ones

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      set: [{ id: 32 }, { id: 42 }],
    },
  },
})
```

## <inlinecode>connect</inlinecode>

<AlgoliaTerm name="apiReference" value="connect" />

A nested `connect` query connects a record to an existing related record by specifying an ID or unique identifier. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

### Remarks

- `connect` is available as a nested query when you create a new parent record or update an existing parent record.
- If the related record does not exist, Prisma Client throws an exception:

  ```
  The required connected records were not found. Expected 1 records to be connected, found 0.
  ```

### Examples

#### Create a new `Profile` record and connect it to an existing `User` record via unique field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

#### Create a new `Profile` record and connect it to an existing `User` record via an ID field

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    user: {
      connect: { id: 42 }, // sets userId of Profile record
    },
  },
})
```

In [2.11.0](https://github.com/prisma/prisma/releases/2.11.0) and later, you can set the foreign key directly:

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'Hello World',
    userId: 42,
  },
})
```

#### Create a new `Post` record and connect it to an existing `User` record

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})
```

#### Update an existing `User` record by connecting it to an existing `Profile` record

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connect: { id: 24 },
    },
  },
})
```

#### Update an existing `User` record by connecting it to two existing `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connect: [{ id: 24 }, { id: 42 }],
    },
  },
})
```

## <inlinecode>connectOrCreate</inlinecode>

<AlgoliaTerm name="apiReference" value="connectOrCreate" />

`connectOrCreate` _either_ connects a record to an existing related record by ID or unique identifier _or_ creates a new related record if the record does not exist. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

### Remarks

<!-- prettier-ignore-start -->

- Multiple `connectOrCreate` queries that run _as concurrent transactions_ can result in a **race condition**. Consider the following example, where two queries attempt to `connectOrCreate` a blog post tag named `computing` at the same time (tag names must be unique):

  <TabbedContent tabs={[<FileWithIcon text="Query A" icon="code"/>, <FileWithIcon text="Query B" icon="code"/>]}>
  <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to create a compiler',
      content: '...',
      author: {
        connect: {
          id: 9,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
    <tab>

  ```ts
  const createPost = await prisma.post.create({
    data: {
      title: 'How to handle schema drift in production',
      content: '...',
      author: {
        connect: {
          id: 15,
        },
      },
      tags: {
        connectOrCreate: {
          create: {
            name: 'computing',
          },
          where: {
            name: 'computing',
          },
        },
      },
    },
  })
  ```

  </tab>
  </TabbedContent>

  If query A and query B overlap in the following way, query A results in an exception:

  | Query A (Fail ❌)                                                | Query B (Success ✅)                                             |
  | :--------------------------------------------------------------- | :--------------------------------------------------------------- |
  | Query hits server, starts transaction A                          | Query hits server, starts transaction B                          |
  |                                                                  | Find record where `tagName` equals `computing`, record not found |
  | Find record where `tagName` equals `computing`, record not found |                                                                  |
  |                                                                  | Create record where `tagName` equals `computing` and connect     |
  | Create record where `tagName` equals `computing`                 |                                                                  |
  | Unique violation, record already created by transaction B        |                                                                  |

  To work around this scenario, we recommend catching the unique violation exception (`PrismaClientKnownRequestError`, error `P2002`) and retrying failed queries.

<!-- prettier-ignore-end -->

### Examples

#### Create a new `Profile` record, then connect it to an existing `User` record _or_ create a new `User`

The following example:

1. Creates a `Profile`
2. Attempts to connect the profile to a `User` where the email address is `alice@prisma.io`
3. Creates a new user if a matching user does not exist

```ts
const user = await prisma.profile.create({
  data: {
    bio: 'The coolest Alice on the planet',
    user: {
      connectOrCreate: {
        where:  { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io'}
    },
  },
})
```

#### Create a new `Post` record and connect it to an existing `User` record, _or_ create a new `User`

```ts
const user = await prisma.post.create({
  data: {
    title: 'Hello World',
    author: {
      connectOrCreate: {
        where: { email: 'alice@prisma.io' },
        create: { email: 'alice@prisma.io' },
      },
    },
  },
})
```

#### Update an existing `User` record by connecting it to an existing `Profile` record, _or_ creating a new `Profile` record

The following example:

1. Attempts to connect the user to a `Profile` with an `id` of `20`
2. Creates a new profile if a matching profile does not exist

```ts
const updateUser = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      connectOrCreate: {
        where: { id: 20 },
        create: {
          bio: 'The coolest Alice in town',
        },
      },
    },
  },
})
```

#### Update an existing `User` record by connect it to two existing `Post` records, or creating two new `Post` records

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      connectOrCreate: [
        {
          where: { id: 32 },
          create: { title: 'This is my first post' },
        },
        {
          where: { id: 19 },
          create: { title: 'This is my second post' },
        },
      ],
    },
  },
})
```

## <inlinecode>disconnect</inlinecode>

<AlgoliaTerm name="apiReference" value="disconnect" />

A nested `disconnect` query breaks the connection between a parent record and a related record, but does not delete either record. See: [Working with relations](/concepts/components/prisma-client/relation-queries) <span class="concept"></span>

### Remarks

- `disconnect` is only available if the relation is optional.
- If the relationship you are attempting to disconnect does not exist:

  - ([In 2.21.0 and later](https://github.com/prisma/prisma/releases/tag/2.21.0)), the operation does nothing
  - (Before [2.21.0](https://github.com/prisma/prisma/releases/tag/2.21.0)) Prisma Client throws an exception if the provided ID or unique identifier is not connected:

    ```
    The records for relation `PostToUser` between the `User` and `Post` models are not connected.
    ```

### Examples

#### Update an existing `User` record by disconnecting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'bob@prisma.io' },
  data: {
    profile: {
      disconnect: true,
    },
  },
})
```

#### Update an existing `User` record by disconnecting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      disconnect: [{ id: 44 }, { id: 46 }],
    },
  },
})
```

## <inlinecode>update</inlinecode>

<AlgoliaTerm name="apiReference" value="update" />

A nested `update` query updates one or more related records where the parent record's ID is `n`. See: [Working with relations](/concepts/components/prisma-client/relation-queries#update-a-specific-related-record) <span class="concept"></span>

### Remarks

- Nested `update` queries are only available in the context of a top-level `update` query (for example, `prisma.user.update(...)`).
- If the parent record does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

- If the related record that you want to update does not exist, Prisma Client throws an exception:

  ```
  AssertionError("Expected a valid parent ID to be present for nested update to-one case.")
  ```

### Examples

#### Update an existing `User` record by updating the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      update: { bio: 'Hello World' },
    },
  },
})
```

#### Update an existing `User` record by updating two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      update: [
        {
          data: { published: true },
          where: { id: 32 },
        },
        {
          data: { published: true },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

## <inlinecode>upsert</inlinecode>

<AlgoliaTerm name="apiReference" value="upsert" />

A nested `upsert` query updates a related record if it exists, or creates a new related record.

### Examples

#### Update an existing `User` record by updating the `Profile` record it's connected to or creating a new one (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      upsert: {
        create: { bio: 'Hello World' },
        update: { bio: 'Hello World' },
      },
    },
  },
})
```

#### Update an existing `User` record by updating two `Post` record it's connected to or creating new ones (_upsert_)

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      upsert: [
        {
          create: { title: 'This is my first post' },
          update: { title: 'This is my first post' },
          where: { id: 32 },
        },
        {
          create: { title: 'This is mt second post' },
          update: { title: 'This is mt second post' },
          where: { id: 23 },
        },
      ],
    },
  },
})
```

## <inlinecode>delete</inlinecode>

<AlgoliaTerm name="apiReference" value="delete" />

A nested `delete` query deletes a related record. The parent record is not deleted.

### Remarks

- `delete` is only available if the relation is optional.

### Examples

#### Update an existing `User` record by deleting the `Profile` record it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    profile: {
      delete: true,
    },
  },
})
```

#### Update an existing `User` record by deleting two `Post` records it's connected to

```ts
const user = await prisma.user.update({
  where: { email: 'alice@prisma.io' },
  data: {
    posts: {
      delete: [{ id: 34 }, { id: 36 }],
    },
  },
})
```

## <inlinecode>updateMany</inlinecode>

<AlgoliaTerm name="apiReference" value="updateMany" />

A nested `updateMany` updates a list of related records and supports filtering - for example, you can update a user's unpublished posts.

### Examples

#### Update all unpublished posts belonging to a specific user

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    posts: {
      updateMany: {
        where: {
          published: false,
        },
        data: {
          likes: 0,
        },
      },
    },
  },
})
```

## <inlinecode>deleteMany</inlinecode>

<AlgoliaTerm name="apiReference" value="deleteMany" />

A nested `deleteMany` deletes related records and supports filtering. For example, you can delete a user's posts while updating other properties of that user.

### Examples

#### Delete all posts belonging to a specific user as part of an update

```ts
const result = await prisma.user.update({
  where: {
    id: 2,
  },
  data: {
    name: 'Updated name',
    posts: {
      deleteMany: {},
    },
  },
})
```

