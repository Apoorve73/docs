## Model query options

### <inlinecode>select</inlinecode>

`select` defines which fields are included in the object that Prisma Client returns. See: [Select fields and include relations](/concepts/components/prisma-client/select-fields) <span class="concept"></span>.

#### Remarks

- You cannot combine `select` and `include` on the same level.
- In [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [select a `_count` of relations](#select-a-_count-of-relations).

#### Reference

```ts file=index.d.ts
export type UserSelect = {
  id?: boolean
  name?: boolean
  email?: boolean
  profileViews?: boolean
  role?: boolean
  coinflips?: boolean
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### Examples

##### Select the `name` and `profileViews` fields of a single `User` record

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findUnique({
  where: { id: 1 },
  select: {
    name: true,
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  name: "Alice",
  profileViews: 0
}
```

</cmdResult>
</CodeWithResult>

##### Select the `email` and `role` fields of a multiple `User` records

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
;[
  {
    email: 'alice@prisma.io',
    role: 'ADMIN',
  },
  {
    email: 'bob@prisma.io',
    role: 'USER',
  },
]
```

</cmdResult>
</CodeWithResult>

##### Select a `_count` of relations

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  select: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  _count: {
    posts: 3
  }
}
```

</cmdResult>
</CodeWithResult>

##### Select the 'id' and 'title' fields of related `Post` records

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      select: {
        id: true,
        title: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```ts no-copy
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      { id: 1, title: 'Hello World' },
      { id: 2, title: 'Bye bye' },
    ],
  },
  {
    id: 2,
    name: 'Bob',
    posts: [],
  },
]
```

</cmdResult>
</CodeWithResult>

##### `include` inside `select`

<CodeWithResult>
<cmd>

```ts
const result = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    posts: {
      include: {
        author: true,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
;[
  {
    id: 1,
    name: 'Alice',
    posts: [
      {
        id: 1,
        title: 'Hello World',
        published: true,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'ADMIN',
          coinflips: [true, false],
          profileViews: 0,
        },
      },
      {
        id: 2,
        title: 'Bye bye',
        published: false,
        author: {
          id: 1,
          name: 'Alice',
          email: 'alice@prisma.io',
          role: 'USER',
          coinflips: [],
          profileViews: 0,
        },
      },
    ],
  },
]
```

</cmdResult>
</CodeWithResult>

#### Generated types for `select`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `select`:

- `SelectAndInclude`
- `UserSelect`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserSelect
const selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({
  name: true,
  email: true,
  posts: false,
})
```

### <inlinecode>include</inlinecode>

`include` defines which relations are included in the result that Prisma Client returns. See: [Select fields and include relations](/concepts/components/prisma-client/select-fields) <span class="concept"></span>.

#### Remarks

- In [3.0.1](https://github.com/prisma/prisma/releases/3.0.1) and later, you can [`include` a `_count` of relations](#include-a-_count-of-relations)

#### Reference

```ts
export type UserInclude = {
  posts?: boolean | PostFindManyArgs
  _count?: boolean | UserCountOutputTypeArgs
}
```

#### Examples

##### Include the `posts` and `profile` relation when loading `User` records

```ts
const users = await prisma.user.findMany({
  include: {
    posts: true, // Returns all fields for all posts
    profile: true, // Returns all Profile fields
  },
})
```

##### Include the `posts` relation on the returned objects when creating a new `User` record with two `Post` records

```ts
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'This is my first post' },
        { title: 'Here comes a second post' },
      ],
    },
  },
  include: { posts: true }, // Returns all fields for all posts
})
```

#### Generated types for `include`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `include`:

- `SelectAndInclude`
- `UserInclude`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
  select: {
    name: true,
  },
  include: {
    email: true,
  },
})

// UserInclude
const includePosts = Prisma.validator<Prisma.UserInclude>()({
  posts: true,
})
```

##### Include a `_count` of relations

<CodeWithResult>
<cmd>

```ts
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{ id: 1, name: "Bob", email: "bob@prisma.io", _count: { posts: 3 } },
{ id: 2,  name: "Enya", email: "enya@prisma.io", _count: { posts: 2 } }
```

</cmdResult>
</CodeWithResult>

### <inlinecode>where</inlinecode>

`where` defines one or more [filters](#filter-conditions-and-operators), and can be used to filter on record properties (like a user's email address) or related record properties (like a user's top 10 most recent post titles).

#### Reference

For queries like `findMany` and `updateMany` that return multiple records, `where` accepts the following input type:

```ts file=index.d.ts
export type UserWhereInput = {
  AND?: Enumerable<UserWhereInput>
  OR?: Enumerable<UserWhereInput>
  NOT?: Enumerable<UserWhereInput>
  id?: IntFilter | number
  name?: StringNullableFilter | string | null
  email?: StringFilter | string
  profileViews?: IntFilter | number
  role?: EnumRoleFilter | Role
  coinflips?: BoolNullableListFilter
  posts?: PostListRelationFilter
}
```

> `findFirst` is a `findMany` query with a `take: 1`, and also accepts `UserWhereInput`.

For queries like `findUnique`, which returns a single record by ID or unique identifier, `where` accepts the following input type:

```ts file=index.d.ts
export type UserWhereUniqueInput = {
  id?: number
  email?: string
}
```

#### Examples

```ts
const results = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
  },
})
```

#### Generated types for `where`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `where`:

- `UserWhereInput`

  ```ts
  // UserWhereInput
  const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
    name: 'Rich',
  })

  // It can be combined with conditional operators too
  const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
    name: 'Rich',
    AND: [
      {
        email: {
          contains: 'rich@boop.com',
        },
      },
    ],
  })
  ```

- `UserWhereUniqueInput` This type works by exposing any unique fields on the model. A field assigned `@id` is considered unique,
  as is one assigned `@unique`.

  From version 4.5.0, this type exposes all fields on the model. This means that when you filter for a single record based on a unique field, you can check additional non-unique and unique fields at the same time. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput).

```ts
// UserWhereUniqueInput
const whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({
  email: 'rich@boop.com',
})
```

- `PostScalarWhereInput`

  ```ts
  const whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({
    title: 'boop',
  })
  ```

- `PostUpdateWithWhereUniqueWithoutAuthorInput` - This type accepts a unique `where` field (an `@id` or another assigned `@unique`)
  and updates any field on the `Post` model except the `Author`. The `Author` is the scalar field on the `Post` model.

  ```ts
  const updatePostByIdWithoutAuthor =
    Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({
      where: {
        id: 1,
      },
      data: {
        content: 'This is some updated content',
        published: true,
        title: 'This is a new title',
      },
    })
  ```

- `PostUpsertWithWhereUniqueWithoutAuthorInput` - This type will update the `Post` records title field where the id matches, if it doesn't exist it will create it instead.

  ```ts
  const updatePostTitleOrCreateIfNotExist =
    Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({
      where: {
        id: 1,
      },
      update: {
        title: 'This is a new title',
      },
      create: {
        id: 1,
        title: 'If the title doesnt exist, then create one with this text',
      },
    })
  ```

- `PostUpdateManyWithWhereWithoutAuthorInput` - This type will update all `Post` records where published is set to false.

  ```ts
  const publishAllPosts =
    Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({
      where: {
        published: {
          equals: false,
        },
      },
      data: {
        published: true,
      },
    })
  ```

### <inlinecode>orderBy</inlinecode>

Sorts a list of records. See also: [Sorting](/concepts/components/prisma-client/filtering-and-sorting) <span class="concept"></span>

#### Remarks

- In [2.16.0](https://github.com/prisma/prisma/releases/2.16.0) and later, you can [order by relation fields](#sort-post-by-the-related-user-records-name) - for example, order posts by the author's name.

- In [3.5.0](https://github.com/prisma/prisma/releases/3.5.0) and later, in PostgreSQL you can [order by relevance](#sort-post-by-relevance-of-the-title). For details, see [Sort by relevance](/concepts/components/prisma-client/filtering-and-sorting#sort-by-relevance-postgresql).

- In [4.1.0](https://github.com/prisma/prisma/releases/4.1.0) and later, you can [sort `null` records first or last](#sort-post-by-the-related-user-records-name-with-null-records-first). For details, see [Sort with nulls first or last](/concepts/components/prisma-client/filtering-and-sorting#sort-with-null-records-first-or-last).

#### Inputs for <inlinecode>sort</inlinecode> argument

| Name   | Description                  |
| ------ | ---------------------------- |
| `asc`  | Sort ascending (A &rarr; Z)  |
| `desc` | Sort descending (Z &rarr; A) |

#### Inputs for <inlinecode>nulls</inlinecode> argument

Note:

- This argument is optional.
- It is for use on optional [scalar](/concepts/components/prisma-schema/data-model#scalar-fields) fields only. If you try to sort by nulls on a required or [relation](/concepts/components/prisma-schema/data-model#relation-fields) field, Prisma Client throws a [P2009 error](/reference/api-reference/error-reference#p2009).
- It is available in version 4.1.0 and later, as a preview feature. See [sort with nulls first or last](/concepts/components/prisma-client/filtering-and-sorting#sort-with-null-records-first-or-last) for details of how to enable the feature.

| Name    | Description                    |
| ------- | ------------------------------ |
| `first` | Sort with `null` values first. |
| `last`  | Sort with `null` values last.  |

#### Reference

`orderBy` accepts the following input type:

```ts file=index.d.ts
export type UserOrderByInput = {
  id?: SortOrder
  name?: SortOrder | SortOrderInput
  email?: SortOrder
  profileViews?: SortOrder
  role?: SortOrder
  coinflips?: SortOrder
  posts?: PostOrderByRelationAggregateInput
  city?: SortOrder
  country?: SortOrder
  profile?: ExtendedProfileOrderByWithRelationAndSearchRelevanceInput
  pets?: SortOrder
  _relevance?: UserOrderByRelevanceInput
}

export type SortOrderInput = {
  sort: SortOrder
  nulls?: NullsOrder
}
```

Related types:

```ts
export declare const SortOrder: {
  asc: 'asc'
  desc: 'desc'
}

export declare const NullsOrder: {
  first: 'first'
  last: 'last'
}

export type PostOrderByRelationAggregateInput = {
  _count?: SortOrder
}

export type ExtendedProfileOrderByWithRelationAndSearchRelevanceInput = {
  id?: SortOrder
  userId?: SortOrder
  bio?: SortOrder
  User?: UserOrderByWithRelationAndSearchRelevanceInput
  _relevance?: ExtendedProfileOrderByRelevanceInput
}

export type UserOrderByRelevanceInput = {
  fields: Enumerable<UserOrderByRelevanceFieldEnum>
  sort: SortOrder
  search: string
}
```

#### Examples

##### Sort `User` by `email` field

The following example returns all `User` records sorted by `email` ascending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
})
```

The following example returns all `User` records sorted by `email` descending:

```ts
const users = await prisma.user.findMany({
  orderBy: {
    email: 'desc',
  },
})
```

#### Sort `Post` by the related `User` record's `name`

The following query orders posts by user name:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: 'asc',
    },
  },
})
```

#### Sort `Post` by the related `User` record's `name`, with `null` records first

The following query orders posts by user name, with `null` records first:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    author: {
      name: { sort: 'asc', nulls: 'first' },
    },
  },
})
```

#### Sort `Post` by relevance of the title

<Admonition type="warning">

This feature is available from version 3.5.0 onwards in PostgreSQL only. You'll need to use the `fullTextSearch` preview flag to enable this feature.

</Admonition>

The following query orders posts by relevance of the search term `'database'` to the title:

```ts
const posts = await prisma.post.findMany({
  orderBy: {
    _relevance: {
      fields: ['title'],
      search: 'database',
      sort: 'asc'
    },
})
```

#### Sort `User` by the `posts` count

The following query orders users by post count:

```ts
const getActiveusers = await prisma.user.findMany({
  orderBy: {
    posts: {
      count: 'desc',
    },
  },
})
```

##### Sort `User` by multiple fields - `email` _and_ `role`

The following example sorts users by two fields - first `email`, then `role`:

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      email: 'desc',
    },
    {
      role: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  }
]
```

</cmdResult>

</CodeWithResult>

The order of sorting parameters matters - the following query sorts by `role`, then `email`. Not the difference in the results:

<CodeWithResult>

<cmd>

```ts
const users = await prisma.user.findMany({
  select: {
    email: true,
    role: true,
  },
  orderBy: [
    {
      role: 'desc',
    },
    {
      email: 'desc',
    },
  ],
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "email": "mary@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "elsa@prisma.io",
    "role": "MODERATOR"
  },
  {
    "email": "yuki@prisma.io",
    "role": "USER"
  },
  {
    "email": "nora@prisma.io",
    "role": "USER"
  },
  {
    "email": "eloise@prisma.io",
    "role": "USER"
  },
  {
    "email": "anna@prisma.io",
    "role": "USER"
  },
  {
    "email": "alice@prisma.io",
    "role": "USER"
  },
  {
    "email": "coco@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

##### Sort `User` by `email`, select `name` and `email`

The following example returns all the `name` and `email` fields of all `User` records, sorted by `email`:

<CodeWithResult>

<cmd>

```ts
const users3 = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  select: {
    name: true,
    email: true,
  },
})
```

</cmd>

<cmdResult>

```js no-copy
;[
  {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
  {
    name: 'Ariadne',
    email: 'ariadne@prisma.io',
  },
  {
    name: 'Bob',
    email: 'bob@prisma.io',
  },
]
```

</cmdResult>

</CodeWithResult>

##### Sort `User` records by `email` and sort nested `Post` records by `title`

The following example:

- Returns all `User` records sorted by `email`
- For each `User` record, returns the `title` field of all nested `Post` records sorted by `title`

<CodeWithResult>

<cmd>

```ts
const usersWithPosts = await prisma.user.findMany({
  orderBy: {
    email: 'asc',
  },
  include: {
    posts: {
      select: {
        title: true,
      },
      orderBy: {
        title: 'asc',
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "id": 2,
    "email": "alice@prisma.io",
    "name": "Alice",
    "posts": [
      {
        "title": "Watch the talks from Prisma Day 2019"
      }
    ]
  },
  {
    "id": 3,
    "email": "ariadne@prisma.io",
    "name": "Ariadne",
    "posts": [
      {
        "title": "How to connect to a SQLite database"
      },
      {
        "title": "My first day at Prisma"
      }
    ]
  },
  {
    "id": 1,
    "email": "bob@prisma.io",
    "name": "Bob",
    "posts": [
      {
        "title": "Follow Prisma on Twitter"
      },
      {
        "title": "Subscribe to GraphQL Weekly for community news "
      }
    ]
  }
]
```

</cmdResult>

</CodeWithResult>

##### Sort one user's nested list of `Post` records

The following example retrieves a single `User` record by ID, as well as a list of nested `Post` records sorted by `title`:

<CodeWithResult>

<cmd>

```ts
const userWithPosts = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
        published: true,
      },
    },
  },
})
```

</cmd>

<cmdResult>

```json no-copy
{
  "email": "sarah@prisma.io",
  "id": 1,
  "name": "Sarah",
  "extendedProfile": null,
  "role": "USER",
  "posts": [
    {
      "title": "Prisma Day 2020",
      "published": false
    },
    {
      "title": "My first post",
      "published": false
    },
    {
      "title": "All about databases",
      "published": true
    }
  ]
}
```

</cmdResult>

</CodeWithResult>

##### Sort by `enum`

The following sorts all `User` records by `role` (an `enum`):

<CodeWithResult>

<cmd>

```ts
const sort = await prisma.user.findMany({
  orderBy: {
    role: 'desc',
  },
  select: {
    email: true,
    role: true,
  },
})
```

</cmd>

<cmdResult>

```json no-copy
[
  {
    "email": "emma@prisma.io",

    "role": "USER"
  },
  {
    "email": "suma@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "kwame@prisma.io",
    "role": "ADMIN"
  },
  {
    "email": "pearl@prisma.io",
    "role": "ADMIN"
  }
]
```

</cmdResult>

</CodeWithResult>

#### Generated types for `orderBy`

The following examples demonstrate how to use the [`validator`](/concepts/components/prisma-client/advanced-type-safety/prisma-validator) with `orderBy`:

- `UserOrderByInput`
  ```ts
  const orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({
    email: 'desc',
  })
  ```

### <inlinecode>distinct</inlinecode>

See also: [Aggregation, grouping, and summarizing](/concepts/components/prisma-client/aggregation-grouping-summarizing#select-distinct) <span class="concept"></span>

#### Reference

```ts file=index.d.ts
distinct?: Enumerable<UserDistinctFieldEnum>
```

```ts
export declare const UserDistinctFieldEnum: {
  id: 'id'
  name: 'name'
  email: 'email'
  profileViews: 'profileViews'
  role: 'role'
  coinflips: 'coinflips'
}
```

#### Examples

##### Select distinct on a single field

The following example returns all distinct `city` fields, and selects only the `city` and `country` fields:

<CodeWithResult  expanded={true}>

<cmd>

```ts
const distinctCities = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city'],
})
```

</cmd>

<cmdResult>

```js no-lines no-copy
;[
  { city: 'Paris', country: 'France' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

##### Select distinct on multiple fields

The following example returns all distinct `city` _and_ `country` field combinations, and selects only the `city` and `country` fields:

<CodeWithResult expanded={true}>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js no-lines no-copy
;[
  { city: 'Paris', country: 'France' },
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

Note that there is now a "Paris, Denmark" in addition to "Paris, France":

##### Select distinct in combination with a filter

The following example returns all distinct `city` _and_ `country` field combinations where the user's email contains `"prisma.io"`, and selects only the `city` and `country` fields:

<CodeWithResult>

<cmd>

```ts
const distinctCitiesAndCountries = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  select: {
    city: true,
    country: true,
  },
  distinct: ['city', 'country'],
})
```

</cmd>

<cmdResult>

```js no-copy
;[
  { city: 'Paris', country: 'Denmark' },
  { city: 'Lyon', country: 'France' },
]
```

</cmdResult>

</CodeWithResult>

