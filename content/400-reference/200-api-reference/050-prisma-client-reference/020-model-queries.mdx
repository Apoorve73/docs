## Model queries

Use model queries to perform CRUD operations on your models. See also: [CRUD](/concepts/components/prisma-client/crud) <span class="concept"></span>

### <inlinecode>findUnique</inlinecode>

`findUnique` query lets you retrieve a single database record:

- By _ID_
- By a _unique_ attribute

`findUnique` replaced `findOne` in version [2.12.0](https://github.com/prisma/prisma/releases/tag/2.12.0).

#### Remarks

- Prisma's dataloader [automatically batches `findUnique` queries](/guides/performance-and-optimization/query-optimization-performance#solving-n1-in-graphql-with-findunique-and-prismas-dataloader) with the same `select` and `where` parameters.
- If you want the query to throw an error if the record is not found, then consider using [`findUniqueOrThrow`](#finduniqueorthrow) instead.

#### Options

| Name                            | Example type (`User`)    | Required | Description                                                                                                                                                                                                                                                       |
| ------------------------------- | ------------------------ | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`                         | `UserWhereUniqueInput`   | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput)                                         |
| `select`                        | `XOR<UserSelect, null>`  | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                                 |
| `include`                       | `XOR<UserInclude, null>` | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                                 |
| `rejectOnNotFound` (deprecated) | `RejectOnNotFound`       | No       | If true, throw a `NotFoundError: No User found error`. You can also [configure `rejectOnNotFound` globally](#rejectonnotfound). <br></br>**Note:** `rejectOnNotFound`is deprecated in v4.0.0. From v4.0.0, use [`findUniqueOrThrow`](#finduniqueorthrow) instead. |

#### Return type

| Return type               | Example                    | Description                                                                                                                                                       |
| ------------------------- | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     |                                                                                                                                                                   |
| JavaScript object (plain) | `{ title: "Hello world" }` | Use `select` and `include` to determine which fields to return.                                                                                                   |
| `null`                    | `null`                     | Record not found                                                                                                                                                  |
| Error                     |                            | If `rejectOnNotFound` is true, `findUnique` throws an error (`NotFoundError` by default, [customizable globally](#rejectonnotfound)) instead of returning `null`. |

#### Reference

`findUnique` accepts the following input type:

```ts file=index.d.ts
export type UserFindUniqueArgs = {
  where: UserWhereUniqueInput
  select?: UserSelect | null
  include?: UserInclude | null
}
```

#### Examples

##### Get the `User` record with an `id` of `42`

```ts
const result = await prisma.user.findUnique({
  where: {
    id: 42,
  },
})
```

##### Get the `User` record with an `email` of `alice@prisma.io`

```ts
const result = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
})
```

##### Get the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@unique`)

<details><summary>Expand for example User model with a @@unique block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@unique(fields: [firstName, lastName], name: "fullname")
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    fullname: {
      // name property of @@unique attribute - default is firstname_lastname
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

##### Get the `User` record with `firstName` of `Alice` and `lastName` of `Smith` (`@@id`)

<details><summary>Expand for example User model with an @@id block</summary>

```prisma
model User {
  firstName String
  lastName  String

  @@id([firstName, lastName])
}
```

</details>

```ts
const result = await prisma.user.findUnique({
  where: {
    firstName_lastName: {
      firstName: 'Alice',
      lastName: 'Smith',
    },
  },
})
```

### <inlinecode>findUniqueOrThrow</inlinecode>

<Admonition type="info">

We introduced `findUniqueOrThrow` in v4.0.0. It replaces the [`rejectOnNotFound`](#rejectonnotfound) option. `rejectOnNotFound` is deprecated in v4.0.0.

</Admonition>

`findUniqueOrThrow` retrieves a single data record in the same way as [`findUnique`](#findunique). However, if the query does not find a record, it returns `NotFoundError: No User found error`.

`findUniqueOrThrow` differs from `findUnique` as follows:

- Its return type is non-nullable. For example, `post.findUnique()` can return `post` or `null`, but `post.findUniqueOrThrow()` always returns `post`.
- It is not compatible with sequential operations in the [`$transaction` API](/concepts/components/prisma-client/transactions#the-transaction-api). If the query returns `NotFoundError`, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the `$transaction` API, as follows:

  ```ts
   $transaction(async (prisma) => {
     await prisma.model.create({ data: { ... });
     await prisma.model.findUniqueOrThrow();
   })
  ```

### <inlinecode>findFirst</inlinecode>

`findFirst` returns the first record in a list that matches your criteria.

#### Remarks

- If you want the query to throw an error if the record is not found, then consider using [`findFirstOrThrow`](#findfirstorthrow) instead.

#### Options

| Name                            | Example type (`User`)                                        | Required | Description                                                                                                                                                                                                                                                     |
| ------------------------------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `distinct`                      | `Enumerable<UserDistinct`<br />`FieldEnum>`                  | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                                                                       |
| `where`                         | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                                                                            |
| `cursor`                        | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                                                                            |
| `orderBy`                       | `XOR<Enumerable<User`<br />`OrderByInput>,UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                                                                               |
| `include`                       | `XOR<UserInclude, null>`                                     | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                               |
| `select`                        | `XOR<UserSelect, null>`                                      | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                               |
| `skip`                          | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                                                                       |
| `take`                          | `number`                                                     | No       | Specifies how many objects should be returned in the list. When used with `findFirst`, `take` is implicitly `1` or `-1`. `findFirst` is only affected by whether the value is positive or negative - any negative value reverses the list.                      |
| `rejectOnNotFound` (deprecated) | `RejectOnNotFound`                                           | No       | If true, throw a `NotFoundError: No User found error`. You can also [configure `rejectOnNotFound` globally](#rejectonnotfound). <br></br>**Note:** `rejectOnNotFound`is deprecated in v4.0.0. From v4.0.0, use [`findFirstOrThrow`](#findfirstorthrow) instead. |

#### Return type

| Return type               | Example                    | Description                                                                                                                                                       |
| ------------------------- | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed) | `User`                     | Specifies which properties to include on the returned object.                                                                                                     |
| JavaScript object (plain) | `{ title: "Hello world" }` | Use `select` and `include` to determine which fields to return.                                                                                                   |
| `null`                    | `null`                     | Record not found                                                                                                                                                  |
| Error                     |                            | If `rejectOnNotFound` is true, `findUnique` throws an error (`NotFoundError` by default, [customizable globally](#rejectonnotfound)) instead of returning `null`. |

#### Remarks

- `findFirst` calls `findMany` behind the scenes and accepts the same query options.
- Passing in a negative `take` value when you use a `findFirst` query reverses the order of the list.

#### Reference

`findFirst` accepts the following input type:

```ts file=index.d.ts
export type UserFindFirstArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

##### Get the first `User` record where the `name` is `Alice`

```ts
const user = await prisma.user.findFirst({
  where: { name: 'Alice' },
})
```

##### Get the first `Post` record where the `title` starts with `A test`, reverse the list with `take`

```ts
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({})

async function main() {
  const a = await prisma.post.create({
    data: {
      title: 'A test 1',
    },
  })

  const b = await prisma.post.create({
    data: {
      title: 'A test 2',
    },
  })

  const c = await prisma.post.findFirst({
    where: {
      title: {
        startsWith: 'A test',
      },
    },
    orderBy: {
      title: 'asc',
    },
    take: -1, // Reverse the list
  })
}

main()
```

### <inlinecode>findFirstOrThrow</inlinecode>

<Admonition type="info">

We introduced `findFirstOrThrow` in v4.0.0. It replaces the [`rejectOnNotFound`](#rejectonnotfound) option. `rejectOnNotFound` is deprecated in v4.0.0.

</Admonition>

`findFirstOrThrow` retrieves the first record in a list in the same way as [`findFirst`](#findfirst). However, if the query does not find a record, it returns `NotFoundError: No User found error`.

`findFirstOrThrow` differs from `findFirst` as follows:

- Its return type is non-nullable. For example, `post.findFirst()` can return `post` or `null`, but `post.findFirstOrThrow` always returns `post`.
- It is not compatible with sequential operations in the [`$transaction` API](/concepts/components/prisma-client/transactions#the-transaction-api). If the query returns `NotFoundError`, then the API will not roll back any operations in the array of calls. As a workaround, you can use interactive transactions with the `$transaction` API, as follows:

```ts
prisma.$transaction(async (tx) => {
  await tx.model.create({ data: { ... });
  await tx.model.findFirstOrThrow();
})
```

### <inlinecode>findMany</inlinecode>

<AlgoliaTerm name="apiReference" value="findMany" />

`findMany` returns a list of records.

#### Options

| Name       | Type                                                          | Required | Description                                                                                                                                                                                               |
| ---------- | ------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`    | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy`  | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `skip`     | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `cursor`   | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `take`     | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `select`   | `XOR<PostSelect, null>`                                       | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                         |
| `include`  | `XOR<PostInclude, null>`                                      | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                         |
| `distinct` | `Enumerable<UserDistinctFieldEnum>`                           | No       | Lets you filter out duplicate rows by a specific field - for example, return only distinct `Post` titles.                                                                                                 |

#### Return type

| Return type                     | Example                      | Description                                                     |
| ------------------------------- | ---------------------------- | --------------------------------------------------------------- |
| JavaScript array object (typed) | `User[]`                     |                                                                 |
| JavaScript array object (plain) | `[{ title: "Hello world" }]` | Use `select` and `include` to determine which fields to return. |
| Empty array                     | `[]`                         | No matching records found.                                      |

#### Reference

`findMany` accepts the following input type:

```ts file=index.d.ts
export type UserFindManyArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}
```

#### Examples

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter results.

##### Get all `User` records where the `name` is `Alice`

```ts
const user = await prisma.user.findMany({
  where: { name: 'Alice' },
})
```

### <inlinecode>create</inlinecode>

`create` creates a new database record.

#### Options

| Name                  | Type                                                     | Required | Description                                                                                                                                                                                                                                                                   |
| --------------------- | -------------------------------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserCreateInput,` <br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| [`select`](#select)   | `XOR<UserSelect, null>`                                  | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                                             |
| [`include`](#include) | `XOR<UserInclude, null>`                                 | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                                             |

#### Return type

| Return type               | Example                        | Description                                                     |
| ------------------------- | ------------------------------ | --------------------------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |

#### Remarks

- You can also perform a nested [`create`](#create-1) - for example, add a `User` and two `Post` records at the same time.

#### Reference

`create` accepts the following input type:

```ts file=index.d.ts
export type UserCreateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserCreateInput, UserUncheckedCreateInput>
}
```

#### Examples

##### Create a single new record with the only required field `email`

```ts
const user = await prisma.user.create({
  data: { email: 'alice@prisma.io' },
})
```

##### Create multiple new records

In most cases, you can carry out batch inserts with the [`createMany`](#createmany) query. However, [there are scenarios where `create` is the best option to insert multiple records](#remarks-10).

The following example results in **two** `INSERT` statements:

<CodeWithResult expanded={true}>

<cmd>

```ts
import { Prisma, PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({ log: ['query'] })

async function main() {
  let users: Prisma.UserCreateInput[] = [
    {
      email: 'ariana@prisma.io',
      name: 'Ari',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
    {
      email: 'elsa@prisma.io',
      name: 'Elsa',
      profileViews: 20,
      coinflips: [true, false, false],
      role: 'ADMIN',
    },
  ]

  await Promise.all(
    users.map(async (user) => {
      await prisma.user.create({
        data: user,
      })
    })
  )
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
```

</cmd>

<cmdResult>

```sql no-copy
prisma:query BEGIN
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query INSERT INTO "public"."User" ("name","email","profileViews","role","coinflips") VALUES ($1,$2,$3,$4,$5) RETURNING "public"."User"."id"
prisma:query COMMIT
prisma:query SELECT "public"."User"."id", "public"."User"."name", "public"."User"."email", "public"."User"."profileViews", "public"."User"."role", "public"."User"."coinflips" FROM "public"."User" WHERE "public"."User"."id" = $1 LIMIT $2 OFFSET $3
prisma:query COMMIT
```

</cmdResult>

</CodeWithResult>

### <inlinecode>update</inlinecode>

`update` updates an existing database record.

#### Options

| Name                  | Type                                                   | Required | Description                                                                                                                                                                                                               |
| --------------------- | ------------------------------------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`                | `XOR<UserUpdateInput`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                 |
| `where`               | `UserWhereUniqueInput`                                 | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput) |
| [`select`](#select)   | `XOR<UserSelect, null>`                                | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                         |
| [`include`](#include) | `XOR<UserInclude, null>`                               | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                         |

#### Return type

| Return type                | Example                        | Description                                                     |
| -------------------------- | ------------------------------ | --------------------------------------------------------------- |
| JavaScript object (typed)  | `User`                         |                                                                 |
| JavaScript object (plain)  | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |
| `RecordNotFound` exception |                                | Exception is thrown if record does not exist.                   |

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-number-operations) to prevent race conditions.
- You can also perform a nested [`update`](#update-1) - for example, update a user and that user's posts at the same time.

#### Reference

```ts file=index.d.ts
export type UserUpdateArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  where: UserWhereUniqueInput
}
```

#### Examples

##### Update the `email` of the `User` record with `id` of `1` to `alice@prisma.io`

```ts
const user = await prisma.user.update({
  where: { id: 1 },
  data: { email: 'alice@prisma.io' },
})
```

### <inlinecode>upsert</inlinecode>

`upsert` does the following:

- If an existing database record satisfies the `where` condition, it updates that record
- If no database record satisfies the `where` condition, it creates a new database record

#### Options

| Name                  | Type                                                    | Required | Description                                                                                                                                                                                                                                                                |
| --------------------- | ------------------------------------------------------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `create`              | `XOR<UserCreateInput,`<br />`UserUncheckedCreateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `update`              | `XOR<UserUpdateInput,`<br />`UserUncheckedUpdateInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional.                                                                                  |
| `where`               | `UserWhereUniqueInput`                                  | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput)                                                  |
| [`select`](#select)   | `XOR<UserSelect, null>`                                 | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                                                                          |
| [`include`](#include) | `XOR<UserInclude, null>`                                | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                                                                          |

#### Return type

| Return type               | Example                        | Description                                                     |
| ------------------------- | ------------------------------ | --------------------------------------------------------------- |
| JavaScript object (typed) | `User`                         |                                                                 |
| JavaScript object (plain) | `{ name: "Alice Wonderland" }` | Use `select` and `include` to determine which fields to return. |

#### Remarks

- To perform arithmetic operations on update (add, subtract, multiply, divide), use [atomic updates](#atomic-number-operations) to prevent race conditions.
- If two or more upsert operations happen at the same time and the record doesn't already exist, then a race condition might happen. As a result, one or more of the upsert operations might throw a unique key constraint error. Your application code can catch this error and retry the operation. [Learn more](#unique-key-constraint-errors-on-upserts).
- From version 4.6.0, Prisma hands over upsert queries to the database where possible. [Learn more](#database-upserts).

#### Reference

`upsert` accepts the following input type:

```ts file=index.d.ts
export type UserUpsertArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
  create: XOR<UserCreateInput, UserUncheckedCreateInput>
  update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
}
```

#### Examples

##### Update (if exists) or create a new `User` record with an `email` of `alice@prisma.io`

```ts
const user = await prisma.user.upsert({
  where: { id: 1 },
  update: { email: 'alice@prisma.io' },
  create: { email: 'alice@prisma.io' },
})
```

#### Unique key constraint errors on upserts

##### Problem

If multiple upsert operations happen at the same time and the record doesn't already exist, then one or more of the operations might return a [unique key constraint error](/reference/api-reference/error-reference#p2002).

##### Cause

When Prisma does an upsert, it first checks whether that record already exists in the database. To make this check, Prisma performs a read operation with the `where` clause from the upsert operation. This has two possible outcomes, as follows:

- If the record does not exist, then Prisma creates that record.
- If the record exists, then Prisma updates it.

When your application tries to perform two or more concurrent upsert operations, then a race condition might happen where two or more operations do not find the record and therefore try to create that record. In this situation, one of the operations succesfully creates the new record but the other operations fail and return a unique key constraint error.

##### Solution

Handle the P2002 error in your application code. When it occurs, retry the upsert operation to update the row.

#### Database upserts

Where possible, Prisma Client hands over an `upsert` query to the database. This is called a _database upsert_.

Database upserts have the following advantages:

- They are faster than upserts handled by Prisma
- [Unique key constraint errors](#unique-key-constraint-errors-on-upserts) cannot happen

Prisma Client uses a database upsert automatically when [specific criteria](#database-upsert-query-criteria) are met. When these criteria are not met, Prisma Client handles the `upsert`.

To use a database upsert, Prisma Client sends the SQL construction [`INSERT ... ON CONFLICT SET .. WHERE`](https://www.prisma.io/dataguide/postgresql/inserting-and-modifying-data/insert-on-conflict) to the database.

##### Database upsert prerequisites

Prisma Client can use database upserts if your stack meets the following criteria:

- You use Prisma version 4.6.0 or later
- Your application uses a CockroachDB, PostgreSQL, or SQLite data source

##### Database upsert query criteria

Prisma Client uses a database upsert for an `upsert` query when the query meets the following criteria:

- There are no nested queries in the `upsert`'s `create` and `update` [options](#options-7)
- The query does _not_ include a selection that uses a [nested read](/concepts/components/prisma-client/relation-queries#nested-reads)
- The query modifies only one model
- There is only one unique field in the `upsert`'s `where` option
- The unique field in the `where` option and the unique field in the `create` option have the same value

If your query does not meet these criteria, then Prisma Client handles the upsert itself.

##### Database upsert examples

The following examples use this schema:

```prisma
model User {
  id           Int    @id
  profileViews Int
  userName     String @unique
  email        String

  @@unique([id, profileViews])
}
```

The following `upsert` query meets all of the criteria, so Prisma Client uses a database upsert.

```ts
prisma.user.upsert({
  where: {
    userName: 'Alice',
  },
  create: {
    id: 1,
    profileViews: 1,
    userName: 'Alice',
    email: 'alice@prisma.io',
  },
  update: {
    email: 'updated@example.com',
  },
})
```

In this situation, Prisma uses the following SQL query:

```sql
INSERT INTO "public"."User" ("id","profileViews","userName","email") VALUES ($1,$2,$3,$4)
ON CONFLICT ("userName") DO UPDATE
SET "email" = $5 WHERE ("public"."User"."userName" = $6 AND 1=1) RETURNING "public"."User"."id", "public"."User"."profileViews", "public"."User"."userName", "public"."User"."email"
```

The following query has multiple unique values in the `where` clause, so Prisma Client does _not_ use a database upsert:

```ts
prisma.User.upsert({
  where: {
    userName: 'Alice',
    profileViews: 1,
    id: 1,
  },
  create: {
    id: 1,
    profileViews: 1,
    userName: 'Alice',
    email: 'alice@prisma.io',
  },
  update: {
    email: 'updated@example.com',
  },
})
```

In the following query, the values for `userName` in the `where` and `create` options are different, so Prisma Client does _not_ use a database upsert.

```ts
prisma.User.upsert({
  where: {
    userName: 'Alice',
  },
  create: {
    id: 1,
    profileViews: 1,
    userName: 'AliceS',
    email: 'alice@prisma.io',
  },
  update: {
    email: 'updated@example.com',
  },
})
```

In the following query, the selection on the `title` field in `posts` is a nested read, so Prisma Client does _not_ use a database upsert.

```ts
prisma.user.upsert({
  select: {
    email: true,
    id: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
  where: {
    userName: 'Alice',
  },

  create: {
    id: 1,
    profileViews: 1,
    userName: 'Alice',
    email: 'alice@prisma.io',
  },
  update: {
    email: 'updated@example.com',
  },
})
```

### <inlinecode>delete</inlinecode>

`delete` deletes an existing database record. You can delete a record:

- By _ID_
- By a _unique_ attribute

To delete records that match a certain criteria, use [`deleteMany`](#deletemany) with a filter.

#### Options

| Name                  | Type                     | Required | Description                                                                                                                                                                                                               |
| --------------------- | ------------------------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`               | `UserWhereUniqueInput`   | **Yes**  | Wraps all _unique_ fields of a model so that individual records can be selected. <br></br>From version 4.5.0, this type wraps all fields of a model. [Learn more](#filter-on-non-unique-fields-with-userwhereuniqueinput) |
| [`select`](#select)   | `XOR<UserSelect, null>`  | No       | [Specifies which properties to include](/concepts/components/prisma-client/select-fields) on the returned object.                                                                                                         |
| [`include`](#include) | `XOR<UserInclude, null>` | No       | [Specifies which relations should be eagerly loaded](/concepts/components/prisma-client/relation-queries) on the returned object.                                                                                         |

#### Return type

| Return type                | Example                        | Description                                                                                                   |
| -------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| JavaScript object (typed)  | `User`                         | The `User` record that was deleted.                                                                           |
| JavaScript object (plain)  | `{ name: "Alice Wonderland" }` | Data from the `User` record that was deleted. Use `select` and `include` to determine which fields to return. |
| `RecordNotFound` exception |                                | Throws an exception if record does not exist.                                                                 |

#### Remarks

- To delete multiple records based on some criteria (for example, all `User` records with a `prisma.io` email address, use `deleteMany`)

#### Reference

`delete` accepts the following input type:

```ts file=index.d.ts
export type UserDeleteArgs = {
  select?: XOR<UserSelect, null>
  include?: XOR<UserInclude, null>
  where: UserWhereUniqueInput
}
```

#### Examples

##### Delete the `User` record with an `id` of `1`

```ts
const user = await prisma.user.delete({
  where: { id: 1 },
})
```

##### Delete the `User` record where `email` equals `else@prisma.io`

The following query deletes a specific user record and uses `select` to return the `name` and `email` of the deleted user:

<CodeWithResult expanded="{true}">

<cmd>

```ts
const deleteUser = await prisma.user.delete({
  where: {
    email: 'elsa@prisma.io',
  },
  select: {
    email: true,
    name: true,
  },
})
```

</cmd>

<cmdResult>

```json no-copy
{ "email": "elsa@prisma.io", "name": "Elsa" }
```

</cmdResult>

</CodeWithResult>

### <inlinecode>createMany</inlinecode>

`createMany` creates multiple records in a transaction.

#### Options

| Name              | Type                              | Required | Description                                                                                                                                                                                                                                                                   |
| ----------------- | --------------------------------- | -------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`            | `Enumerable<UserCreateManyInput>` | **Yes**  | Wraps all the model fields in a type so that they can be provided when creating new records. It also includes relation fields which lets you perform (transactional) nested inserts. Fields that are marked as optional or have default values in the datamodel are optional. |
| `skipDuplicates?` | `boolean`                         | No       | Do not insert records with unique fields or ID fields that already exist. Only supported by databases that support [`ON CONFLICT DO NOTHING`](https://www.postgresql.org/docs/9.5/sql-insert.html#SQL-ON-CONFLICT). This excludes MongoDB and SQLServer                       |

#### Return type

| Return type    | Example        | Description                               |
| -------------- | -------------- | ----------------------------------------- |
| `BatchPayload` | `{ count: 3 }` | A count of the number of records created. |

#### Remarks

- `createMany` is not supported by SQLite.
- The `skipDuplicates` option is not supported by MongoDB and SQLServer.
- You **cannot** create or connect relations - you cannot nest `create`, `createMany`, `connect`, `connectOrCreate` inside a top-level `createMany`
- You can nest a [`createMany`](#createmany-1) inside an `update` or `create` query - for example, add a `User` and two `Post` records at the same time.

#### Reference

`createMany` accepts the following input type:

```ts file=index.d.ts
export type UserCreateManyArgs = {
  data: Enumerable<UserCreateManyInput>
  skipDuplicates?: boolean
}
```

#### Examples

##### Create several new users

```ts
const users = await prisma.user.createMany({
  data: [
    { name: 'Sonali', email: 'sonali@prisma.io' },
    { name: 'Alex', email: 'alex@prisma.io' },
  ],
})
```

### <inlinecode>updateMany</inlinecode>

`updateMany` updates a batch of existing database records in bulk and returns the number of updated records.

#### Options

| Name    | Type                                                                    | Required | Description                                                                                                                                                                                         |
| ------- | ----------------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `data`  | `XOR<UserUpdateManyMutationInput,`<br />`UserUncheckedUpdateManyInput>` | **Yes**  | Wraps all the fields of the model so that they can be provided when updating an existing record. Fields that are marked as optional or have default values in the datamodel are optional on `data`. |
| `where` | `UserWhereInput`                                                        | No       | Wraps _all_ fields of a model so that the list can be filtered by any property. If you do not filter the list, all records will be updated.                                                         |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Reference

`updateMany` accepts the following input type:

```ts file=index.d.ts
export type UserUpdateManyArgs = {
  data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
  where?: UserWhereInput
}
```

#### Examples

##### Update all `User` records where the `name` is `Alice` to `ALICE`

```ts
const updatedUserCount = await prisma.user.updateMany({
  where: { name: 'Alice' },
  data: { name: 'ALICE' },
})
```

##### Update all `User` records where the `email` contains `prisma.io` and at least one related `Post` has more than 10 likes

```ts
const deleteUser = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io',
    },
    posts: {
      some: {
        likes: {
          gt: 10,
        },
      },
    },
  },
  data: {
    role: 'USER',
  },
})
```

### <inlinecode>deleteMany</inlinecode>

`deleteMany` deletes multiple records in a transaction.

#### Options

| Name    | Type             | Required | Description                                                                  |
| ------- | ---------------- | -------- | ---------------------------------------------------------------------------- |
| `where` | `UserWhereInput` | No       | Wraps _all_ fields of a model so that the list can be filtered by any field. |

#### Return type

| Return type    | Example        | Description                   |
| -------------- | -------------- | ----------------------------- |
| `BatchPayload` | `{ count: 4 }` | The count of updated records. |

```ts
export type BatchPayload = {
  count: number
}
```

#### Reference

`deleteMany` accepts the following input type:

```ts file=index.d.ts
export type UserDeleteManyArgs = {
  where?: UserWhereInput
}
```

#### Examples

##### Delete all `User` records

```ts
const deletedUserCount = await prisma.user.deleteMany({})
```

##### Delete all `User` records where the `name` is `Alice`

```ts
const deletedUserCount = await prisma.user.deleteMany({
  where: { name: 'Alice' },
})
```

See [Filter conditions and operators](#filter-conditions-and-operators) for examples of how to filter the records to delete.

### <inlinecode>count</inlinecode>

#### Options

| Name      | Type                                                          | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                              | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `cursor`  | `UserWhereUniqueInput`                                        | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `skip`    | `number`                                                      | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                      | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `orderBy` | `XOR<Enumerable<PostOrder`<br />`ByInput>, PostOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `select`  | `UserCountAggregateInputType`                                 | No       | Select which fields to count (non-`null` values) - you can also count `_all`.                                                                                                                             |

#### Return type

| Return type                    | Example                  | Description                   |
| ------------------------------ | ------------------------ | ----------------------------- |
| `number`                       | `29`                     | The count of records.         |
| `UserCountAggregateOutputType` | `{ _all: 27, name: 10 }` | Returned if `select` is used. |

#### Reference

`count` accepts the following input type:

```ts file=index.d.ts
export type UserFindManyArgs = {
  // select and include are excluded
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
}

export type UserCountAggregateOutputType = {
  id: number
  name: number | null
  email: number | null
  profileViews: number
  role: number | null
  coinflips: number | null
  testing: number | null
  city: number | null
  country: number | null
  _all: number
}
```

#### Examples

##### Count all `User` records

```ts
const result = await prisma.user.count()
```

##### Count all `User` records with at least one published `Post`

```ts
const result = await prisma.user.count({
  where: {
    post: {
      some: {
        published: true,
      },
    },
  },
})
```

##### Use `select` to perform three separate counts

The following query returns:

- A count of all records (`_all`)
- A count of all records with non-`null` `name` fields
- A count of all records with non-`null` `city` fields

```ts
const c = await prisma.user.count({
  select: {
    _all: true,
    city: true,
    name: true,
  },
})
```

### <inlinecode>aggregate</inlinecode>

See also: [Aggregation, grouping, and summarizing](/concepts/components/prisma-client/aggregation-grouping-summarizing#aggregate) <span class="concept"></span>

#### Options

| Name      | Type                                                         | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy` | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | No       | Lets you order the returned list by any property.                                                                                                                                                         |
| `cursor`  | `UserWhereUniqueInput`                                       | No       | Specifies the position for the list (the value typically specifies an `id` or another unique value).                                                                                                      |
| `skip`    | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                     | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `_count`  | `true`                                                       | No       | Returns a count of matching records or non-`null` fields.                                                                                                                                                 |
| `_avg`    | `UserAvgAggregateInputType`                                  | No       | Returns an average of all values of the specified field.                                                                                                                                                  |
| `_sum`    | `UserSumAggregateInputType`                                  | No       | Returns the sum of all values of the specified field.                                                                                                                                                     |
| `_min`    | `UserMinAggregateInputType`                                  | No       | Returns the smallest available value of the specified field.                                                                                                                                              |
| `_max`    | `UserMaxAggregateInputType`                                  | No       | Returns the largest available value of the specified field.                                                                                                                                               |

#### Reference

`aggregate` accepts the following input type:

```ts file=index.d.ts
export type UserAggregateArgs = {
  where?: UserWhereInput
  orderBy?: XOR<Enumerable<UserOrderByInput>, UserOrderByInput>
  cursor?: UserWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<UserDistinctFieldEnum>
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### Examples

##### Return `_min`, `_max`, and `_count` of `profileViews` of all `User` records

<CodeWithResult>
<cmd>

```ts
const minMaxAge = await prisma.user.aggregate({
  _count: {
    _all: true,
  },
  _max: {
    profileViews: true,
  },
  _min: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  _count: { _all: 29 },
  _max: { profileViews: 90 },
  _min: { profileViews: 0 }
}
```

</cmdResult>
</CodeWithResult>

##### Return `_sum` of all `profileViews` for all `User` records

<CodeWithResult>
<cmd>

```ts
const setValue = await prisma.user.aggregate({
  _sum: {
    profileViews: true,
  },
})
```

</cmd>
<cmdResult>

```js no-copy
{
  "_sum": {
    "profileViews": 9493
  }
}
```

</cmdResult>
</CodeWithResult>

### <inlinecode>groupBy</inlinecode>

See also: [Aggregation, grouping, and summarizing](/concepts/components/prisma-client/aggregation-grouping-summarizing#group-by) <span class="concept"></span>

#### Options

| Name      | Type                                                         | Required | Description                                                                                                                                                                                               |
| --------- | ------------------------------------------------------------ | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `where`   | `UserWhereInput`                                             | No       | Wraps _all_ model fields in a type so that the list can be filtered by any property.                                                                                                                      |
| `orderBy` | `XOR<Enumerable<UserOrderByInput>,`<br />`UserOrderByInput>` | No       | Lets you order the returned list by any property that is also present in `by`.                                                                                                                            |
| `by`      | `Array<UserScalarFieldEnum>`                                 | No       | Specifies the field or combination of fields to group records by.                                                                                                                                         |
| `having`  | `UserScalarWhereWithAggregatesInput`                         | No       | Allows you to filter groups by an aggregate value - for example, only return groups _having_ an average age less than 50.                                                                                 |
| `skip`    | `number`                                                     | No       | Specifies how many of the returned objects in the list should be skipped.                                                                                                                                 |
| `take`    | `number`                                                     | No       | Specifies how many objects should be returned in the list (as seen from the _beginning_ (positive value) or _end_ (negative value) **either** of the list **or** from the `cursor` position if mentioned) |
| `_count`  | `true` \| `UserCountAggregateInputType`                      | No       | Returns a count of matching records or non-`null` fields.                                                                                                                                                 |
| `_avg`    | `UserAvgAggregateInputType`                                  | No       | Returns an average of all values of the specified field.                                                                                                                                                  |
| `_sum`    | `UserSumAggregateInputType`                                  | No       | Returns the sum of all values of the specified field.                                                                                                                                                     |
| `_min`    | `UserMinAggregateInputType`                                  | No       | Returns the smallest available value of the specified field.                                                                                                                                              |
| `_max`    | `UserMaxAggregateInputType`                                  | No       | Returns the largest available value of the specified field.                                                                                                                                               |

#### Reference

`groupBy` accepts the following input type:

```ts file=index.d.ts
export type UserGroupByArgs = {
  where?: UserWhereInput
  orderBy?: Enumerable<UserOrderByInput>
  by: Array<UserScalarFieldEnum>
  having?: UserScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: true | UserCountAggregateInputType
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}
```

#### Examples

##### Group by `country`/`city` where the average `profileViews` is greater than `200`, and return the `_sum` of `profileViews` for each group

The query also returns a count of `_all` records in each group, and all records with non-`null` `city` field values in each group.

<CodeWithResult expanded="{true}">
<cmd>

```ts
const groupUsers = await prisma.user.groupBy({
  by: ['country', 'city'],
  _count: {
    _all: true,
    city: true,
  },
  _sum: {
    profileViews: true,
  },
  orderBy: {
    country: 'desc',
  },
  having: {
    profileViews: {
      _avg: {
        gt: 200,
      },
    },
  },
})
```

</cmd>
<cmdResult>

```js no-copy
;[
  {
    country: 'Denmark',
    city: 'Copenhagen',
    _sum: { profileViews: 490 },
    _count: {
      _all: 70,
      city: 8,
    },
  },
  {
    country: 'Sweden',
    city: 'Stockholm',
    _sum: { profileViews: 500 },
    _count: {
      _all: 50,
      city: 3,
    },
  },
]
```

</cmdResult>
</CodeWithResult>

